% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_basisFun_mem.R
\name{time_basisFun_mem}
\alias{time_basisFun_mem}
\title{Fit a mixed-effects model with a set of by-time basis functions}
\usage{
time_basisFun_mem(
  formula_mem,
  data_mem,
  ...,
  groupingVarName,
  timeVarName,
  basisDens = "wide",
  basis_calc_fun = "gaussian",
  backend = c("lmer", "glmer", "brm"),
  n_oos = 0
)
}
\arguments{
\item{formula_mem}{Mixed-effects model formula, as in \code{\link[lme4]{glmer}} or \code{\link[brms]{brm}}}

\item{data_mem}{Data frame to fit model}

\item{...}{Additional arguments to pass to the fitting function (e.g., \code{brm})}

\item{groupingVarName}{Character. Variable name, within \code{data_mem}, by which basis functions should be grouped (i.e., defined for each one).}

\item{timeVarName}{Character. Variable name, within \code{data_mem}, over which basis functions should be defined (e.g., trial number).}

\item{basisDens}{Numeric scalar. Distance between basis function peaks, on the same scale as \code{timeVarName}}

\item{basis_calc_fun}{Name of the method to calculate bases. Currently only "gaussian" is supported}

\item{backend}{Character. Name of fitting function (i.e., \code{lmer}, \code{glmer}, or \code{brm})}

\item{n_oos}{Numeric scalar. Number of times to re-fit the model with random 98/2 cross-validation. This provides an estimate of out-of-sample predictiveness.}
}
\description{
Given a typical [generalized] mixed-effects model, augment this model
using a random-effects structure including basis functions constructed 
from a vector of times (e..g, trial numbers).
This allows for simultaneously controlling for time-related variations, and for 
recovery of those variations from the fitted model.
}
\details{
Various fitting functions (\code{backends}) can be used, such as 
\code{\link[lme4]{lmer}}, \code{\link[lme4]{glmer}}, and \code{\link[brms]{brm}}. 
These require that their respective packages and dependencies be installed.

In the case that out-of-sample likelihoods are desired, see 
`attr(modelObject,'delta_logLik_outOfSample_description')` for a description and
`attr(mod,'delta_logLik_outOfSample')` for the vector of out-of-sample delta-log-likelihoods. 
Out-of-sample log-likelihoods are calculated as an difference from the pointwise in-sample 
likelihood from a static fit (i.e., a model fit with only \code{formula_mem} and no bases).
This provides a uniform baseline pointwise in-sample likelihood against which various 
models (e.g., with different basis densities) can be compared.
}
\examples{
 d <- data.frame(
     subID = rep(c('A','B','C'),each=200)
   , x = rbinom(600,1,.5)
   , sinOffset = sin((1:600)/10) # one possible kind of change: oscillation without trend
   , trialNum = rep(1:200, 3)
) ; d$y <- rnorm(600) + d$x + d$sinOffset
m1 <- time_basisFun_mem(
   y ~ x + (x|subID)
   ,d
   ,groupingVarName = 'subID'
   ,timeVarName = 'trialNum'
)

## overall model summary:
summary(m1)

## extract the fitted timecourse:
m1_fitted_timeCourse <- predict(m1,random.only=T
   ,re.form = as.formula(paste('~',gsub('x + (x | subID) + ','',as.character(formula(m1))[3],fixed=T)) ) )
plot(d$trialNum,m1_fitted_timeCourse)
## it doesn't look very good, because the default basis function width is fairly wide to prevent overfitting
#
## let's compare two models' out-of-sample likelihoods and choose the best
#
## The default, conservative, size (see m1)
m2 <- time_basisFun_mem(
   y ~ x + (x|subID)
   ,d
   ,groupingVarName = 'subID'
   ,timeVarName = 'trialNum'
   ,basisDens = 66
   ,n_oos = 50
)
#
## A less-dense set of bases, every 20 trials
m3 <- time_basisFun_mem(
   y ~ x + (x|subID)
   ,d
   ,groupingVarName = 'subID'
   ,timeVarName = 'trialNum'
   ,basisDens = 20
   ,n_oos = 50
)
#
## approximate Cohen's D:
(mean(attr(m3,'delta_logLik_outOfSample')) - mean(attr(m2,'delta_logLik_outOfSample')) )/
   sd(c(attr(m3,'delta_logLik_outOfSample'),attr(m2,'delta_logLik_outOfSample')))
## Clearly m3's out-of-sample predictiveness is better than m2's
## What about its fitted timecourse?
#
m3_fitted_timeCourse <- predict(m3,random.only=T
   ,re.form = as.formula(paste('~',gsub('x + (x | subID) + ','',as.character(formula(m3))[3],fixed=T)) ) )
plot(d$trialNum,m3_fitted_timeCourse)
## These look much more like the sin-wave oscillations that were originally generated!

}
