#' m <- TEfit(dat[,c('respVar','timeVar','covar1','covar2')],covarTerms=list(pStart=c(F,T),pRate=c(T,T),pAsym=c(T,F)))
#'
#' ## 50 bootstrapped fits:
#'  m <- TEfit(dat[,c('respVar','timeVar')],bootPars=tef_bootList(resamples=50))
#'  summary(m)
#' # view a plot of the model, with CI bands:
#' plot(m)
#' # view the predicted values of the model by plotting data simulated from the parameters:
#' . <- simulate(m,toPlot=T)
#'
#'  ## 50 random-subsample 80/20 cross-validation fits:
#'  m <- TEfit(dat[,c('respVar','timeVar')],bootPars=tef_bootList(resamples=50,bootPercent=.8))
#'  summary(m)
#'
#'  ## ## ## control parameters:
#'
#'  ## Increase convergence tolerance to 0.1:
#'  m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(convergeTol=.1))
#'
#'  ## Increase the maximum run number to 5000 (defaults to 200):
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(nTries=5000))
#'
#'  ## If the function will asymptote in the given time period, then one option is to calculate the TE function stepwise: first get a stable fit of last 20% of timepoints (if there are enough timepoints, average this with a stable fit to the last 10% of timepoints). Then fit the start and rate of approach to this asymptote:
#'  m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(stepwise_asym = T))
#'
#'  ## Put limits on the predicted values:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(y_lim=c(.1,.9)))
#'
#'  ## Put limits on the rate parameter:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(rate_lim=c(2,4)))
#'
#'  ## Remove the constraint that the time-evolving fit values should have the same mean as the null fit values:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(penalizeMean=F))
#'
#'  ## If rate parameter is hitting the boundary, try imposing a slight penalization for extreme rate values:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(penalizeRate=T))
#'
#'  ## Change the exponential change log base from 2 to e:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(expBase=exp(1)))
#'
#'  ## Change the rate parameter log base from 2 to e:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(rateBase=exp(1)))
#'
#'  ## Silence errors:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(quietErrs=T))
#'
#'  ## Fix a parameter [asymptote] to 0.8:
#'   m <- TEfit(dat[,c('respVar','timeVar')],control=tef_control(pFix=list(pAsym=.8)))
#' }
TEfit <- function(varIn,
linkFun = list(link='identity'),
errFun = 'ols',
changeFun = 'expo',
bootPars = tef_bootList(),
blockTimeVar = NULL,
covarTerms = list(),
control=tef_control()
){
modList <- list()
modList$times <- c()
modList$times['start'] <- Sys.time()
## ## ## ## ## ## ## ## ##
## ## >arguments:
{
modList$linkFun <- linkFun
modList$errFun <- errFun
modList$changeFun <- changeFun
modList$bootPars <- bootPars
modList$blockTimeVar <- blockTimeVar
modList$covarTerms <- covarTerms
modList$varIn <- varIn
# # add in trial num, if not included in varIn
if(is.vector(modList$varIn)){
modList$varIn <- data.frame(y=modList$varIn,timeVar=1:length(modList$varIn))
}
if(any(sapply(modList$varIn,class)=='factor')){warning('your data includes factors. Please do not include factor variables.')}
}## ## ##
## ^^ ^^ ^^ ^^ ^^ ^^ ##
## ## ## ## ## ## ## ## ##
## ## >control arguments:
{
if(length(control) < length(tef_control())){stop('\nYou do not have enough control inputs. Please use `control=tef_control()`.\n')}
modList$convergeTol <- control$convergeTol
modList$nTries      <- control$nTries
modList$y_lim       <- control$y_lim
modList$rate_lim    <- control$rate_lim
modList$shape_lim   <- control$shape_lim
modList$expBase     <- control$expBase
modList$rateBase    <- control$rateBase
modList$pFix        <- control$pFix
modList$stepwise_asym<- control$stepwise_asym
modList$penalizeRate<- control$penalizeRate
modList$penalizeMean<- control$penalizeMean
modList$explicit    <- control$explicit
modList$quietErrs   <- control$quietErrs
modList$suppressWarnings <- control$suppressWarnings
}
## ^^ ^^ ^^ ^^ ^^ ^^ ##
## ## ## ## ## ## ## ## ##
## ## >name your response variable and your time variable
modList$respVar <- colnames(modList$varIn)[1]
modList$timeVar <- colnames(modList$varIn)[2]
if(max(xtabs(~modList$varIn[,1]),na.rm=T)/dim(na.omit(modList$varIn))[1]>.9){
warning('\nYour response variable has few unique values. You may not be able to estimate a time-evolving function.\n')
}
## ^^ ^^ ^^ ^^ ^^ ^^ ##
if(modList$errFun=='bernoulli'){
modList$y_lim[1] <- max(modList$y_lim[1],0)
modList$y_lim[2] <- min(modList$y_lim[2],1)
}
modList$times['before_vars2forms'] <- Sys.time() - modList$times['start']
modList <- tef_vars2forms(modList)
## ## ## ## ## ## ## ## ##
## ## > stepwise asymptote option
#### #### ## NEEDS TO BE error checked.
if(modList$stepwise_asym){
if(nrow(modList$varIn)>20){ ## fit stable asymptote to the last 20% (at least 4 obs)
asymModList <- modList
asymModList$varIn <- asymModList$varIn[order(asymModList$varIn[,'timeVar'])[round(nrow(asymModList$varIn)*.8):nrow(asymModList$varIn)],]
stableAsymFit <- tef_tryFits(asymModList,whichPnames = 'null_pNames',whichFun='null_fun')
modList$stable_ending_asym <- stableAsymFit$par
if(nrow(modList$varIn)>40){ ## fit stable asymptote to the last 10% (at least 4 obs)
asymModList <- modList
asymModList$varIn <- asymModList$varIn[order(asymModList$varIn[,'timeVar'])[round(nrow(asymModList$varIn)*.8):nrow(asymModList$varIn)],]
stableAsymFit <- tef_tryFits(asymModList,whichPnames = 'null_pNames',whichFun='null_fun')
modList$stable_ending_asym <- mean(c(modList$stable_ending_asym,stableAsymFit$par))
}
## first, get rid of any other asym things:
if(length(modList$pFix)>0){modList$pFix <- modList$pFix[grep('Asym',names(modList$pFix),invert = T)]}
modList$pFix['pAsym'] <- round(modList$stable_ending_asym,8) ## set the asymtote to a fixed value, based on a stable fit to last bit
modList <- tef_vars2forms(modList) ## re-get the model setup
}else{cat('\nYou have too few observations to fit a stable asymptote to the final 20% of observations\n')}
}
modList$times['vars2forms'] <- Sys.time() - sum(modList$times)
## ## ## ## ## ## ## ## ##
## ## > FIT NULL MODEL
# # CAN GET PARAMETER GUESSES FROM HERE
### ### ### CAN ALSO DO THINGS LIKE REDUCTION TO 2D SEARCH,
# # # # NULL LL VALUES, NULL PREDICTED VALUES, ETC
nullFit <- tef_tryFits(modList,whichPnames = 'null_pNames',whichFun='null_fun')
parDat <- as.data.frame(matrix(nullFit$par[1:length(modList$null_pNames)],dim(modList$varIn)[1],length(modList$null_pNames),byrow=T))
colnames(parDat) <- modList$null_pNames
nullFit$fullDat <- data.frame(modList$varIn,parDat)
modList$nullYhat <- eval(expr=modList$null_fun,env=nullFit$fullDat)
modList$times['nullFits'] <- Sys.time() - sum(modList$times)
## ## ## ## ## ## ## ## ##
## ## > Fit Actual Model:
bestFit <- tef_tryFits(modList)
modList$times['modFits'] <- Sys.time() - sum(modList$times)
if(modList$stepwise_asym){bestFit$par['stepwiseAsym'] <- modList$stable_ending_asym}
##
##
if(modList$linkFun$link=='logit'||modList$linkFun$link=='weibull'){
modList <- tef_getBounds(modList,linkFunX=modList$linkFun[[grep('X',names(modList$linkFun))]])}else{
modList <- tef_getBounds(modList)
}
##
nObs <- length(na.omit(modList$varIn[,1]))
## ## ## ## ## ## ## ## ##
## ## >Get goodness-of-fit metrics
bestFit$GoF <- data.frame(
err = bestFit$value
,nullErr = as.numeric(nullFit$value)
,nPars = length(bestFit$par)
,nObs = nObs
)
rownames(bestFit$GoF) <- modList$errFun
if(modList$errFun == 'ols'){
# get F test here
bestFit$GoF$Fval <-
((bestFit$GoF$nullErr-bestFit$GoF$err)/(bestFit$GoF$nPars-length(modList$null_pNames)))/
(bestFit$GoF$err/(bestFit$GoF$nObs-bestFit$GoF$nPars))
bestFit$GoF$Pval <- 1-pf(bestFit$GoF$Fval,
bestFit$GoF$nPars-1,
bestFit$GoF$nObs-bestFit$GoF$nPars)
bestFit$GoF$Rsquared <- (bestFit$GoF$nullErr-bestFit$GoF$err)/bestFit$GoF$nullErr
## ## ## ##
bestFit$GoF$BIC <- log(bestFit$value/nObs)*nObs + bestFit$GoF$nPars*log(nObs)
bestFit$GoF$nullBIC <- log(nullFit$value/nObs)*nObs + length(nullFit$par)*log(nObs)
bestFit$GoF$deltaBIC <- bestFit$GoF$BIC - bestFit$GoF$nullBIC
}
if(modList$errFun == 'rmse'){
bestFit$GoF$BIC <- log(bestFit$value^2)*nObs + bestFit$GoF$nPars*log(nObs)
bestFit$GoF$nullBIC <- log(nullFit$value^2)*nObs + length(nullFit$par)*log(nObs)
bestFit$GoF$deltaBIC <- bestFit$GoF$BIC - bestFit$GoF$nullBIC
}
if(modList$errFun == 'bernoulli'){
bestFit$GoF$BIC <- bestFit$value*2 + bestFit$GoF$nPars*log(nObs)
bestFit$GoF$nullBIC <- nullFit$value*2 + length(nullFit$par)*log(nObs)
bestFit$GoF$deltaBIC <- bestFit$GoF$BIC - bestFit$GoF$nullBIC
}
if(modList$errFun == 'wiener_dr'){
bestFit$GoF$BIC <- bestFit$value*2 + bestFit$GoF$nPars*log(nObs)
bestFit$GoF$nullBIC <- nullFit$value*2 + length(nullFit$par)*log(nObs)
bestFit$GoF$deltaBIC <- bestFit$GoF$BIC - bestFit$GoF$nullBIC
}
if(modList$errFun=='exGauss_mu' || modList$errFun=='exGauss_tau'){
bestFit$GoF$BIC <- bestFit$value + bestFit$GoF$nPars*log(nObs)
bestFit$GoF$nullBIC <- nullFit$value + length(nullFit$par)*log(nObs)
bestFit$GoF$deltaBIC <- bestFit$GoF$BIC - bestFit$GoF$nullBIC
}
## ^^ ^^ ^^ ^^ ^^ ^^ ##
## ## ## ## ## ## ## ## ##
## ## > Run resampled fits
if(modList$bootPars$nBoots > 0){
bootList <- tef_bootFits(modList)
if(bootList$bootPercent<1){
oosErrMedian <- median(bootList$bootFits$err_oos_mean)
if(modList$errFun == 'rmse'){     ## this is already normalized for nObs
bestFit$GoF$oosErr <- oosErrMedian
}else{        ## this needs to be normalized for nObs
bestFit$GoF$oosErr <- oosErrMedian*nObs
}
# bestFit$GoF$oosBIC <- oosErr*2 + length(modList$pNames)*log(nObs)
bestFit$GoF$oosDeltaErr <- bestFit$GoF$oosErr-bestFit$GoF$nullErr
}
modList$times['bootFits'] <- Sys.time() - sum(modList$times)
} ## ## ##
## ^^ ^^ ^^ ^^ ^^ ^^ ##
## ## ## ## ## ## ## ## ##
## everything beyond here is getting fit vals, plots, etc.
{
parDat <- as.data.frame(matrix(bestFit$par[1:length(modList$pNames)],dim(modList$varIn)[1],length(modList$pNames),byrow=T))
colnames(parDat) <- modList$pNames
bestFit$fullDat <- data.frame(modList$varIn,parDat)
bestFit$fitVals <- eval(expr=modList$evalFun,env=bestFit$fullDat)
if(modList$errFun=='exGauss_tau'){
bestFit$fitVals <- bestFit$par['mu_param'] + (bestFit$fitVals)
}
if(modList$errFun=='exGauss_mu'){
bestFit$fitVals <- bestFit$fitVals + (bestFit$par['tau_param'])
}
if(modList$changeFun=='power4'){
timewarp <- bestFit$fullDat
timewarp[,2] <- timewarp[,2]-bestFit$par[grep('PrevTime',names(bestFit$par))]
timewarpPred <- eval(expr=modList$evalFun,env=timewarp)
bestFit$learning_start_value <- timewarpPred[which.min(modList$varIn[,2])]
}
## ## ## Get residuals
bestFit$model_residuals <- bestFit$fitVals -  modList$varIn[,modList$respVar]
modList$null_residuals  <- modList$nullYhat-  modList$varIn[,modList$respVar]
## <><> PROBLEMATIC FOR WEIBULL AND LOGIT -- NEED TO JUST HAVE A SEPARATE TRACK FOR THEM.
## ## residual vs raw correlation:
bestFit$conditional_independence <- data.frame(
rawSpearman = cor(modList$null_residuals,modList$varIn[,modList$timeVar],use='complete.obs',method='spearman'),
modelConditionalSpearman = cor(bestFit$model_residuals,modList$varIn[,modList$timeVar],use='complete.obs',method='spearman')
)
bestFit$conditional_independence$proportionalSpearmanChange <-
abs(bestFit$conditional_independence$modelConditionalSpearman)/abs(bestFit$conditional_independence$rawSpearman)
## ## if they have the psych package, then get the difference in correlations p value:
try({
bestFit$conditional_independence$pValSpearmanChange <-
psych::r.test(nrow(na.omit(modList$varIn)),
abs(bestFit$conditional_independence$rawSpearman),
abs(bestFit$conditional_independence$modelConditionalSpearman))$p
if(abs(bestFit$conditional_independence$rawSpearman) < abs(bestFit$conditional_independence$modelConditionalSpearman)){
bestFit$conditional_independence$pValSpearmanChange <- max(c(
1-bestFit$conditional_independence$pValSpearmanChange,
bestFit$conditional_independence$pValSpearmanChange
))
}
},silent=F)
## ## if they have the tseries package, then get the null and model residuals' KPSS p values:
try({
suppressWarnings({
null_kpss_p <- tseries::kpss.test(na.omit(modList$null_residuals)[sort(na.omit(modList$varIn[,modList$timeVar]))]
,null='Level')$p.value
modl_kpss_p <- tseries::kpss.test(na.omit(bestFit$model_residuals)[sort(na.omit(modList$varIn[,modList$timeVar]))]
,null='Level')$p.value
})
if(null_kpss_p == .01){null_kpss_p <- '< .01'}
if(modl_kpss_p == .01){modl_kpss_p <- '< .01'}
if(null_kpss_p == .1){null_kpss_p <- '> .1'}
if(modl_kpss_p == .1){modl_kpss_p <- '> .1'}
bestFit$conditional_independence$pval_KPSS_null  <- null_kpss_p
bestFit$conditional_independence$pval_KPSS_model <- modl_kpss_p
},silent=T)
rownames(bestFit$conditional_independence) <- paste0(modList$respVar,' ~ ',modList$timeVar,':')
## <><> for sigmoid links, find the threshold
if(modList$linkFun$link=='logit' || modList$linkFun$link=='weibull'){try({
bestFit$fitThresh <- eval(as.formula(paste('~',modList$thresh_fun))[[2]],env=bestFit$fullDat)
if(modList$changeFun=='power4'){
threshwarp <- eval(as.formula(paste('~',modList$thresh_fun))[[2]],env=timewarp)
# print(threshwarp)
bestFit$learning_start_thresh <- threshwarp[which.min(modList$varIn[,2])]
}
if(modList$bootPars$nBoots > 0){
bootList$bootThresh <- data.frame()
for(curBoot in 1:nrow(bootList$bootFits)){
parDat <- as.data.frame(matrix(unlist(bootList$bootFits[curBoot,1:length(modList$pNames)]),
dim(modList$varIn)[1],length(modList$pNames),byrow=T))
colnames(parDat) <- modList$pNames
curDat <- data.frame(modList$varIn,parDat)
bootList$bootThresh <- rbind(bootList$bootThresh,eval(as.formula(paste('~',modList$thresh_fun))[[2]],env=curDat))
}
bootList$threshCI = list(ci025=apply(bootList$bootThresh,2,quantile,.025),
ci975= apply(bootList$bootThresh,2,quantile,.975))
}
},silent=T)}
if(dim(modList$varIn)[2]>2){
noCovar <- modList$varIn ; noCovar[,3:dim(noCovar)[2]] <- 0
noCovar[,modList$blockTimeVar] <- 1E10
bestFit$fitVals_noCovar <- eval(expr=modList$evalFun,env=data.frame(noCovar,parDat))
}
modList$times['postFit'] <- Sys.time() - sum(modList$times)
modList$times['totalTime'] <- Sys.time() - modList$times[1]
if(modList$bootPars$nBoots > 0){
modList$times['mean_per_boot'] <- modList$times['bootFits']/modList$bootPars$nBoots
}
} ## ##
## ^^ ^^ ^^ ^^ ^^ ^^ ##
## ## ## ## ## ## ## ## ##
## Wrap things up and return them
modList$times <- round(modList$times[2:length(modList$times)],4)
outData <- data.frame(bestFit$fullDat,fitVals=bestFit$fitVals)
if(exists('bootList')){
TEs3 <-list(modList=modList,model=bestFit,nullFit=nullFit,data=outData,bootList=bootList)
}else{
TEs3 <- list(modList=modList,model=bestFit,nullFit=nullFit,data=outData)
}
class(TEs3) <- 'TEfit'
return(TEs3)
}
m1<- TEfit(d[1:100,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),
control = tef_control(suppressWarnings = T,nTries = 50))
install.packages('psych')
#' Fit several time-evolving regression models
#'
#' A wrapper for fitting a \code{\link{TEfit}} model to the data
#' for every unique value of groupingVar. Defaults to
#' returning a list including two summaries and all models; returning
#' only a summary is also an option. Most arguments (except, e.g., \code{groupingVar}, a grouping vector)
#' are identical to, and are passed directly to, \code{\link{TEfit}}.
#'
#' @inheritParams TEfit
#' @param groupingVar Variable (e.g., participant ID) with which to separate TEfit models. Length must be nrows(varIn)
#' @param groupingVarName Name of grouping variable
#' @param returnAll Logical. Return only a summary (when T), or that summary plus every model, in a list (when F)
#' @param progressDot If TRUE, prints a dot after each group fit
#'
#' @seealso
#' \code{\link{TEfit}} for fitting a single model;
#' \code{\link{tef_fitAll2brms}} to re-fit the TEfitAll output using \code{\link[brms]{brms-package}}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' m <- TEfitAll(anstrain[,c('acc','trialNum')],groupingVar = anstrain$subID,groupingVarName = 'subID',bootPars = tef_bootList(resamples = 20))
#' summary(m)
#' }
#'
TEfitAll <- function(varIn,
groupingVar,
groupingVarName = 'grouping_var',
returnAll=T,
progressDot=T,
linkFun = list(link='identity'),
errFun = 'ols',
changeFun = 'expo',
bootPars = tef_bootList(),
blockTimeVar = NULL,
covarTerms = list(),
control=tef_control()
){
TEFitList <- list()
TEFit_group <- data.frame()
fit_data <- data.frame()
for(curGroup in unique(groupingVar)){
TEFitList[[curGroup]] <- TEfit(
varIn=varIn[groupingVar==curGroup,],linkFun=linkFun,errFun=errFun,
changeFun=changeFun,bootPars=bootPars,
blockTimeVar=blockTimeVar,
covarTerms=covarTerms,control=control
)
summLine <- TEFitList[[length(TEFitList)]]$model$par
if(bootPars$nBoots>0){
pseudoSEs <- as.vector(coef(TEFitList[[curGroup]])$pseudoSE)
names(pseudoSEs) <- paste0(rownames(coef(TEFitList[[curGroup]])),'_pseudoSE')
percentIncreasing <- TEFitList[[curGroup]]$bootList$percent_increasing
names(percentIncreasing) <- 'percent_samples_increasing'
summLine <- c(summLine,pseudoSEs,percentIncreasing)
}
TEFit_group <- rbind(TEFit_group,c(
summLine,
TEFitList[[length(TEFitList)]]$model$GoF,
linkFun=linkFun$link,errFun=errFun,changeFun=changeFun,
converged=TEFitList[[length(TEFitList)]]$model$converged
))
try({
TEFit_group <- rbind(TEFit_group,
pValSpearmanChange=as.numeric(TEFitList[[length(TEFitList)]]$model$conditional_independence['pValSpearmanChange'])
)
},silent=T)
rownames(TEFit_group)[nrow(TEFit_group)] <- curGroup
fit_data <- rbind(fit_data,TEFitList[[length(TEFitList)]]$data)
if(progressDot){cat('. ')}
}
## ## ## ## get the overall values, across groupVar subsets
TEFitSummary <- data.frame(summaryStat=c('mean','stdErr'))
for(curCol in 1:ncol(TEFit_group)){
if(is.numeric(TEFit_group[,curCol]) || is.logical(TEFit_group[,curCol])){
TEFitSummary <- cbind(TEFitSummary,
c(mean(TEFit_group[,curCol]),
sd(TEFit_group[,curCol])/sqrt(nrow(TEFit_group)))
)
}else(TEFitSummary <- cbind(TEFitSummary,unique(TEFit_group[,curCol])))
}
rownames(TEFitSummary) <- TEFitSummary$summaryStat
TEFitSummary <- TEFitSummary[,2:ncol(TEFitSummary)]
colnames(TEFitSummary) <- colnames(TEFit_group)
attr(TEFitSummary,'grouping_var') <- groupingVarName
attr(TEFit_group,'grouping_var') <- groupingVarName
attr(TEFitList,'grouping_var') <- groupingVarName
if(returnAll){
outList <- list(fitSummary=TEFitSummary ,allFits = TEFit_group,allFitList = TEFitList,data=fit_data)# return everything that was calculated
class(outList) <- 'TEfitAll'
return(outList)
}else(return(TEFit_group)) # return only the by-groupVar fits
}
rm(list=ls())
library(devtools) ; install('c:/users/uwlat/google drive/functions/fitpack/TEfits')
library(devtools) ; install('c:/users/uwlat/google drive/aaron/functions/fitpack/TEfits')
library(testthat) ; test_package('TEfits')
remove.packages("psych", lib="~/R/win-library/4.0")
library(TEfits)
d <- anstrain
d$absRat <- abs(d$ratio)
d$moreCatA <- as.numeric(d$ratio > 0)
m$ident_ols <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
dent_ols <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
summary(dent_ols)
install.packages('psych')
dent_ols_withPsych <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
summary(dent_ols_withPsych)
library(devtools) ; document('c:/users/uwlat/google drive/aaron/functions/fitpack/TEfits')
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make"
)
remove.packages("psych", lib="~/R/win-library/4.0")
library(devtools) ; install('c:/users/uwlat/google drive/aaron/functions/fitpack/TEfits')
dent_ols_nopsych <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
library(TEfits)
dent_ols_nopsych <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
library(TEfits)
d <- anstrain
d$absRat <- abs(d$ratio)
d$moreCatA <- as.numeric(d$ratio > 0)
dent_ols_nopsych <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
install.packages('psych')
dent_ols_yapsych <- TEfitAll(d[,c('acc','trialNum')],
bootPars = tef_bootList(resamples = 20),groupingVar = d$subID,
control = tef_control(suppressWarnings = T,nTries = 50))
summary(dent_ols_nopsych)
summary(dent_ols_yapsych)
1E0
dent_ols_yapsych$allFits
summary(dent_ols_yapsych$allFits[[1]])
summary(dent_ols_yapsych$allFits[1])
summary(dent_ols_yapsych$allFitList[1])
summary(dent_ols_yapsych$allFitList[[1]])
remove.packages("psych", lib="~/R/win-library/4.0")
library(devtools) ; install('c:/users/uwlat/desktop/TEfits-development/TEfits')
library(testthat) ; test_package('TEfits')
install.packages('psych')
library(testthat) ; test_package('TEfits')
library(devtools) ; install('c:/users/uwlat/google drive/aaron/functions/af_package/AaronFuns')
library(TEfits)
library(AaronFuns)
getTime
load("C:/Users/UWLAT/Google Drive/prep2019/adaptation/Analysis/adaptation_PLfits_2020Jul16_1628.RData")
nIter <- 25000
nMods <- 0 ; while(nMods < 2){try({
m <- tef_fitAll2brms(m_PL$TEfitAll,nIter = nIter,nChains = 1, prior_dispersion = 5)
. <- posterior_summary(m)
save(m,file=paste0('adaptation_learn_',nIter,'its_',getTime(),'.RData'))
})}
knitr::opts_chunk$set(echo = F)
library(readxl)
library(psych)
library(ggplot2)
library(lme4)
library(effects)
library(MASS)
library(knitr)
library(tidyr)
load('annadat_2020Jun13_1554.RData')
source('get_online_dat.R')
load("G:/My Drive/Masha/analysis/annadat_2020Jun13_1554.RData")
library(TEfits)
?TEbrm
m3 <- TEbrm(
acc ~ tef_change_power4('trialNum')
,data = anstrain_s1
,link_start_asym = 'inv_logit'
,family=bernoulli(link='identity')
)
m3
setwd('g:/my drive/aaron/functions/fitpack/TEfits')
